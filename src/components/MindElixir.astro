---
// Componente mejorado para integrar Mind Elixir en Astro con pan táctil
interface Props {
  id?: string;
  data?: any;
  height?: string;
}

const { id = 'mind-map', data, height = '500px' } = Astro.props;

// Datos por defecto para el mapa mental
const defaultData = data || {
  nodeData: {
    id: 'root',
    topic: 'Mapa Mental de Prédicas',
    root: true,
    children: [
      {
        id: '1',
        topic: 'Fundamentos de Fe',
        direction: 0,
        children: [
          { id: '1-1', topic: 'La Salvación', direction: 0 },
          { id: '1-2', topic: 'La Gracia', direction: 0 },
          { id: '1-3', topic: 'El Evangelio', direction: 0 }
        ]
      },
      {
        id: '2',
        topic: 'Vida Cristiana',
        direction: 1,
        children: [
          { id: '2-1', topic: 'Oración', direction: 1 },
          { id: '2-2', topic: 'Lectura Bíblica', direction: 1 },
          { id: '2-3', topic: 'Comunión', direction: 1 }
        ]
      },
      {
        id: '3',
        topic: 'Servicio',
        direction: 0,
        children: [
          { id: '3-1', topic: 'Evangelismo', direction: 0 },
          { id: '3-2', topic: 'Discipulado', direction: 0 }
        ]
      }
    ]
  }
};
---

<link rel="stylesheet" href="/mind-elixir.css" />

<div 
  id={id} 
  class="mind-elixir-container"
  data-mind-data={JSON.stringify(defaultData)}
  style={`height: ${height}; width: 100%; border: 1px solid #ccc; border-radius: 8px; overflow: hidden; position: relative;`}>
</div>

<script>
  import MindElixir from 'mind-elixir';
  
  document.addEventListener('DOMContentLoaded', () => {
    const containers = document.querySelectorAll('.mind-elixir-container');
    
    containers.forEach((container) => {
      const id = container.id;
      const dataStr = container.getAttribute('data-mind-data');
      
      if (dataStr) {
        try {
          const data = JSON.parse(dataStr);
          
          const mind = new MindElixir({
            el: `#${id}`,
            direction: MindElixir.LEFT,
            draggable: true,
            contextMenu: true,
            toolBar: true,
            keypress: true
          });

          mind.init(data);
          
          // Agregar soporte de pan táctil usando transformación
          setTimeout(() => {
            const svg = container.querySelector('svg');
            if (svg) {
              let isPanning = false;
              let startX = 0;
              let startY = 0;
              let currentTranslateX = 0;
              let currentTranslateY = 0;
              
              // Crear grupo wrapper si no existe
              let group = svg.querySelector('.pan-group');
              if (!group) {
                group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.classList.add('pan-group');
                
                // Mover todos los hijos al grupo
                while (svg.firstChild) {
                  group.appendChild(svg.firstChild);
                }
                svg.appendChild(group);
              }
              
              // Variables para zoom
              let currentScale = 1;
              const minScale = 0.5;
              const maxScale = 3;
              
              // Eventos táctiles para pan y zoom
              svg.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                  isPanning = true;
                  startX = e.touches[0].clientX;
                  startY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                  isPanning = false;
                  // Calcular distancia inicial entre dos dedos
                  const dx = e.touches[0].clientX - e.touches[1].clientX;
                  const dy = e.touches[0].clientY - e.touches[1].clientY;
                  startX = Math.sqrt(dx * dx + dy * dy);
                }
              }, { passive: true });
              
              svg.addEventListener('touchmove', (e) => {
                if (isPanning && e.touches.length === 1) {
                  const deltaX = e.touches[0].clientX - startX;
                  const deltaY = e.touches[0].clientY - startY;
                  
                  currentTranslateX += deltaX;
                  currentTranslateY += deltaY;
                  
                  group.setAttribute('transform', `translate(${currentTranslateX}, ${currentTranslateY}) scale(${currentScale})`);
                  
                  startX = e.touches[0].clientX;
                  startY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                  // Zoom con pellizco
                  const dx = e.touches[0].clientX - e.touches[1].clientX;
                  const dy = e.touches[0].clientY - e.touches[1].clientY;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  
                  const scale = distance / startX;
                  const newScale = currentScale * scale;
                  
                  if (newScale >= minScale && newScale <= maxScale) {
                    currentScale = newScale;
                    group.setAttribute('transform', `translate(${currentTranslateX}, ${currentTranslateY}) scale(${currentScale})`);
                    startX = distance;
                  }
                }
              }, { passive: true });
              
              svg.addEventListener('touchend', () => {
                isPanning = false;
              }, { passive: true });
              
              // También agregar soporte para mouse (para testing en desktop)
              let isMousePanning = false;
              let mouseStartX = 0;
              let mouseStartY = 0;
              
              svg.addEventListener('mousedown', (e) => {
                if (e.button === 0 || e.button === 2) { // Click izquierdo o derecho
                  isMousePanning = true;
                  mouseStartX = e.clientX;
                  mouseStartY = e.clientY;
                }
              });
              
              // Zoom con rueda del mouse
              svg.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = currentScale * delta;
                
                if (newScale >= minScale && newScale <= maxScale) {
                  currentScale = newScale;
                  group.setAttribute('transform', `translate(${currentTranslateX}, ${currentTranslateY}) scale(${currentScale})`);
                }
              }, { passive: false });
              
              document.addEventListener('mousemove', (e) => {
                if (isMousePanning) {
                  const deltaX = e.clientX - mouseStartX;
                  const deltaY = e.clientY - mouseStartY;
                  
                  currentTranslateX += deltaX;
                  currentTranslateY += deltaY;
                  
                  group.setAttribute('transform', `translate(${currentTranslateX}, ${currentTranslateY}) scale(${currentScale})`);
                  
                  mouseStartX = e.clientX;
                  mouseStartY = e.clientY;
                }
              });
              
              // Prevenir clic derecho
              svg.addEventListener('contextmenu', (e) => {
                e.preventDefault();
              });
              
              document.addEventListener('mouseup', () => {
                isMousePanning = false;
              });
            }
          }, 500);
          
          console.log('Mind Elixir inicializado correctamente en:', id);
        } catch (err) {
          console.error('Error al inicializar Mind Elixir:', err);
        }
      }
    });
  });
</script>

<style>
  :global(.mind-elixir) {
    font-family: system-ui, -apple-system, sans-serif;
  }
  
  :global(.mind-elixir-toolbar) {
    background: var(--sl-color-bg-nav);
    border-bottom: 1px solid var(--sl-color-gray-5);
  }
  
  :global(.pan-group) {
    transition: none;
  }
</style>
