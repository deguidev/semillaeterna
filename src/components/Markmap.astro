---
import { Transformer } from 'markmap-lib';

interface Props {
  id?: string;
  height?: string;
  content: string;
}

const { id, height = '500px', content } = Astro.props as Props;

if (!content) {
  throw new Error('Markmap: se requiere la prop "content" con el markdown.');
}

const elementId = id ?? `markmap-${Math.random().toString(36).slice(2, 9)}`;

// // URL base para BibleGateway
// const BIBLE_GATEWAY_URL = 'https://www.biblegateway.com/passage/?search=';
// const BIBLE_VERSION = 'RVR1960';

// // Funci√≥n para convertir referencias b√≠blicas en enlaces
// const addBibleLinks = (md: string) => {
//   // Patr√≥n mejorado para detectar referencias b√≠blicas (ej: "Juan 3:16", "1 Corintios 13:1-13", "Salmos 23:1")
//   // Soporta libros con n√∫meros (1 Juan, 2 Corintios), con tildes y la letra √±
//   const bibleRefPattern = /^(\s*-\s+)([0-9]?\s*[A-Z√Å√â√ç√ì√öa-z√°√©√≠√≥√∫√±√ë]+(?:\s+[A-Z√Å√â√ç√ì√öa-z√°√©√≠√≥√∫√±√ë]+)*\s+[0-9]+:[0-9]+(?:-[0-9]+)?)$/gm;
  
//   return md.replace(bibleRefPattern, (match, prefix, reference) => {
//     // Codificar la referencia para URL
//     const encodedRef = encodeURIComponent(reference.trim());
//     // Crear el enlace HTML
//     return `${prefix}<a href="${BIBLE_GATEWAY_URL}${encodedRef}&version=${BIBLE_VERSION}" target="_blank">${reference}</a>`;
//   });
// };

// =============================
// üìñ Conversor de referencias b√≠blicas a enlaces de Bible.com
// Autor: Degui Dev
// =============================

// üåê URL base para Bible.com (versi√≥n espa√±ol)
const BIBLE_COM_BASE_URL = 'https://www.bible.com/es/bible/';

// üî¢ C√≥digo de versi√≥n "149" = Reina-Valera 1960
const BIBLE_COM_VERSION_CODE = '149';

// üìú Versi√≥n textual (para mostrar en el enlace)
const BIBLE_VERSION = 'RVR1960';

// üìö Mapa de abreviaturas oficiales de Bible.com
// (Solo algunos ejemplos, puedes completar con los dem√°s libros)
const bookAbbrevMap: Record<string, string> = {
  // Antiguo Testamento
  "G√©nesis": "GEN",
  "√âxodo": "EXO",
  "Lev√≠tico": "LEV",
  "N√∫meros": "NUM",
  "Deuteronomio": "DEU",
  "Josu√©": "JOS",
  "Jueces": "JDG",
  "Rut": "RUT",
  "1 Samuel": "1SA",
  "2 Samuel": "2SA",
  "1 Reyes": "1KI",
  "2 Reyes": "2KI",
  "1 Cr√≥nicas": "1CH",
  "2 Cr√≥nicas": "2CH",
  "Esdras": "EZR",
  "Nehem√≠as": "NEH",
  "Ester": "EST",
  "Job": "JOB",
  "Salmos": "PSA",
  "Proverbios": "PRO",
  "Eclesiast√©s": "ECC",
  "Cantares": "SNG",
  "Isa√≠as": "ISA",
  "Jerem√≠as": "JER",
  "Lamentaciones": "LAM",
  "Ezequiel": "EZK",
  "Daniel": "DAN",
  "Oseas": "HOS",
  "Joel": "JOL",
  "Am√≥s": "AMO",
  "Abd√≠as": "OBA",
  "Jon√°s": "JON",
  "Miqueas": "MIC",
  "Nah√∫m": "NAM",
  "Habacuc": "HAB",
  "Sofon√≠as": "ZEP",
  "Hageo": "HAG",
  "Zacar√≠as": "ZEC",
  "Malaqu√≠as": "MAL",

  // Nuevo Testamento
  "Mateo": "MAT",
  "Marcos": "MRK",
  "Lucas": "LUK",
  "Juan": "JHN",
  "Hechos": "ACT",
  "Romanos": "ROM",
  "1 Corintios": "1CO",
  "2 Corintios": "2CO",
  "G√°latas": "GAL",
  "Efesios": "EPH",
  "Filipenses": "PHP",
  "Colosenses": "COL",
  "1 Tesalonicenses": "1TH",
  "2 Tesalonicenses": "2TH",
  "1 Timoteo": "1TI",
  "2 Timoteo": "2TI",
  "Tito": "TIT",
  "Filem√≥n": "PHM",
  "Hebreos": "HEB",
  "Santiago": "JAS",
  "1 Pedro": "1PE",
  "2 Pedro": "2PE",
  "1 Juan": "1JN",
  "2 Juan": "2JN",
  "3 Juan": "3JN",
  "Judas": "JUD",
  "Apocalipsis": "REV",
};

// ‚úùÔ∏è Funci√≥n principal para convertir referencias a enlaces de Bible.com
const addBibleLinks = (md: string): string => {
  // Patr√≥n para detectar referencias b√≠blicas (ej: "- Juan 3:16", "- 1 Corintios 13:1-13")
  const bibleRefPattern =
    /^(\s*-\s+)([0-9]?\s*[A-Z√Å√â√ç√ì√öa-z√°√©√≠√≥√∫√±√ë]+(?:\s+[A-Z√Å√â√ç√ì√öa-z√°√©√≠√≥√∫√±√ë]+)*\s+[0-9]+:[0-9]+(?:-[0-9]+)?)$/gm;

  return md.replace(bibleRefPattern, (match, prefix, reference) => {
    // Separar el nombre del libro y el cap√≠tulo/vers√≠culos
    const parts = reference.trim().split(/\s+/);
    const bookName = parts.slice(0, -1).join(' ');
    const chapterAndVerses = parts.slice(-1)[0];

    // Buscar la abreviatura correspondiente
    const abbrev = bookAbbrevMap[bookName];
    if (!abbrev) {
      console.warn(`No se encontr√≥ abreviatura para: ${bookName}`);
      return match; // Devolver el texto original si no se encuentra el libro
    }

    // Reemplazar ":" por "." y mantener el rango si existe (ej: 12:1-2 ‚Üí 12.1-2)
    const formattedVerses = chapterAndVerses.replace(':', '.');

    // Construir la URL final
    const url = `${BIBLE_COM_BASE_URL}${BIBLE_COM_VERSION_CODE}/${abbrev}.${formattedVerses}`;

    // Devolver el texto con enlace HTML
    return `${prefix}<a href="${url}" target="_blank">${reference}</a>`;
  });
};



// Funci√≥n para asegurar que el markdown tenga el formato correcto
const formatMarkdown = (md: string) => {
  // Primero, normalizar los saltos de l√≠nea
  let result = md.replace(/\r\n/g, '\n');
  
  // Asegurar que los elementos de lista usen guiones consistentemente
  result = result.replace(/^\s*\*/gm, '-');
  
  // Preservar la jerarqu√≠a de las listas anidadas
  // Convertir sangr√≠as de tabulaciones a 2 espacios
  result = result.replace(/\t/g, '  ');
  
  // Asegurar que los elementos de lista tengan un espacio despu√©s del gui√≥n
  result = result.replace(/^(\s*)-(\S)/gm, '$1- $2');
  
  // Asegurar que haya una l√≠nea en blanco antes de las listas despu√©s de encabezados
  result = result.replace(/(## .+)\n-/g, '$1\n\n-');
  
  // Agregar enlaces a referencias b√≠blicas
  result = addBibleLinks(result);
  
  return result;
};

const formattedContent = formatMarkdown(content);
const transformer = new Transformer();
const { root } = transformer.transform(formattedContent);
const assets = transformer.getAssets();

const dataStr = JSON.stringify(root ?? {});
const assetsStr = JSON.stringify(assets ?? {});
---

<div class="markmap-wrapper" style={`height: ${height};`}>
  <svg id={elementId} class="markmap-svg" xmlns="http://www.w3.org/2000/svg" data-markmap-data={dataStr}></svg>
</div>


<script>
  import { Markmap } from 'markmap-view';

  // Funci√≥n para obtener los colores seg√∫n el tema actual
  function getColorFunction() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    
    const colors = isDark
      ? ['#60a5fa', '#34d399', '#fbbf24', '#f87171', '#a78bfa', '#fb923c', '#22d3ee', '#fb7185']
      : ['#2563eb', '#059669', '#d97706', '#dc2626', '#7c3aed', '#ea580c', '#0891b2', '#e11d48'];
    
    return (node: any) => colors[node.state.id % colors.length];
  }

  // Funci√≥n para inicializar un markmap espec√≠fico
  function initializeMarkmap(svg: SVGElement) {
    const dataStr = svg.getAttribute('data-markmap-data');
    
    if (!dataStr) {
      return;
    }

    try {
      const data = JSON.parse(dataStr);
      
      const mm = new Markmap(svg, {
        duration: 500,
        maxWidth: 0,
        initialExpandLevel: -1,  // Expandir todos los niveles
        fitRatio: 0.9,           // Ratio de ajuste para dejar margen
        nodeMinHeight: 16,
        spacingVertical: 5,
        spacingHorizontal: 80,
        paddingX: 8,
        color: getColorFunction(),
        autoFit: true,           // Ajuste autom√°tico
        zoom: true,              // Habilitar zoom
        pan: true,               // Habilitar paneo
      });
      
      mm.setData(data);
      
      // Guardar la instancia para poder actualizarla
      (svg as any).__markmap__ = mm;
      
      // Forzar ajuste completo del gr√°fico despu√©s de renderizar
      setTimeout(() => {
        mm.fit();
        updateTextColors();
      }, 150);
      
    } catch (err) {
      console.error('Error al inicializar Markmap:', err);
    }
  }

  // Funci√≥n para actualizar el color del texto en el SVG
  function updateTextColors() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    const textColor = isDark ? '#ffffff' : '#1e293b';
    
    const markmapSvgs = document.querySelectorAll('.markmap-svg');
    markmapSvgs.forEach((svg) => {
      // Actualizar TODOS los elementos de texto sin excepci√≥n
      svg.querySelectorAll('text').forEach((el: any) => {
        el.style.fill = textColor;
        el.setAttribute('fill', textColor);
      });
      
      // Actualizar todos los tspan (texto dentro de los nodos)
      svg.querySelectorAll('tspan').forEach((el: any) => {
        el.style.fill = textColor;
        el.setAttribute('fill', textColor);
      });
      
      // Actualizar todos los elementos foreignObject (si existen)
      svg.querySelectorAll('foreignObject').forEach((el: any) => {
        el.style.color = textColor;
      });
      
      // Actualizar todos los divs dentro del SVG
      svg.querySelectorAll('div').forEach((el: any) => {
        el.style.color = textColor;
      });
      
      // Actualizar enlaces
      svg.querySelectorAll('a').forEach((el: any) => {
        el.style.fill = textColor;
        el.style.color = textColor;
        el.setAttribute('fill', textColor);
      });
      
      // Actualizar cualquier span
      svg.querySelectorAll('span').forEach((el: any) => {
        el.style.color = textColor;
      });
    });
  }

  // Funci√≥n para actualizar los colores cuando cambia el tema
  function updateMarkmapTheme() {
    const markmapSvgs = document.querySelectorAll('.markmap-svg');
    markmapSvgs.forEach((svg) => {
      const mm = (svg as any).__markmap__;
      if (mm) {
        mm.setOptions({ color: getColorFunction() });
        mm.fit();
      }
    });
    
    // Actualizar colores de texto
    updateTextColors();
  }

  // Ocultar cualquier imagen est√°tica que se est√© mostrando
  const hideStaticOverlay = `
    document.querySelectorAll('img[src*="markmap"]').forEach(img => {
      img.style.display = 'none';
    });
  `;

  // Inicializar el markmap
  document.addEventListener('DOMContentLoaded', () => {
    eval(hideStaticOverlay);
    
    const markmapSvgs = document.querySelectorAll('.markmap-svg');
    markmapSvgs.forEach((svg) => {
      while (svg.firstChild) {
        svg.removeChild(svg.firstChild);
      }
      initializeMarkmap(svg as unknown as SVGElement);
    });
  });

  // Tambi√©n inicializar si el DOM ya est√° listo
  if (document.readyState !== 'loading') {
    setTimeout(() => {
      eval(hideStaticOverlay);
      const markmapSvgs = document.querySelectorAll('.markmap-svg');
      markmapSvgs.forEach((svg) => {
        while (svg.firstChild) {
          svg.removeChild(svg.firstChild);
        }
        initializeMarkmap(svg as unknown as SVGElement);
      });
    }, 50);
  }

  // Observar cambios en el atributo data-theme para actualizar los colores
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
        updateMarkmapTheme();
      }
    });
  });

  // Observar el elemento html para detectar cambios de tema
  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['data-theme']
  });
  
  // Aplicar colores de texto al cargar
  setTimeout(() => updateTextColors(), 200);
</script>

<style>
  .markmap-wrapper {
    width: 100%;
    border: 1px solid var(--sl-color-gray-5);
    border-radius: 12px;
    overflow: hidden;
    background: var(--sl-color-bg);
    transition: background-color 0.3s ease, border-color 0.3s ease;
  }

  .markmap-svg {
    width: 100%;
    height: 100%;
  }

  /* Texto de los nodos - forzar colores seg√∫n tema */
  .markmap-svg text,
  .markmap-svg tspan,
  .markmap-svg a,
  .markmap-svg foreignObject,
  .markmap-svg div,
  .markmap-svg span {
    transition: fill 0.3s ease, color 0.3s ease !important;
  }
  
  /* Modo claro - texto oscuro */
  :root[data-theme='light'] .markmap-svg text,
  :root[data-theme='light'] .markmap-svg tspan,
  :root[data-theme='light'] .markmap-svg a,
  :root[data-theme='light'] .markmap-svg foreignObject,
  :root[data-theme='light'] .markmap-svg div,
  :root[data-theme='light'] .markmap-svg span {
    fill: #1e293b !important;
    color: #1e293b !important;
  }

  /* Modo oscuro - texto BLANCO para TODOS los niveles */
  :root[data-theme='dark'] .markmap-svg text,
  :root[data-theme='dark'] .markmap-svg tspan,
  :root[data-theme='dark'] .markmap-svg a,
  :root[data-theme='dark'] .markmap-svg foreignObject,
  :root[data-theme='dark'] .markmap-svg foreignObject *,
  :root[data-theme='dark'] .markmap-svg div,
  :root[data-theme='dark'] .markmap-svg span {
    fill: #ffffff !important;
    color: #ffffff !important;
  }

</style>
