---
import { Transformer } from 'markmap-lib';

interface Props {
  id?: string;
  height?: string;
  content: string;
}

const { id, height = '500px', content } = Astro.props as Props;

if (!content) {
  throw new Error('Markmap: se requiere la prop "content" con el markdown.');
}

const elementId = id ?? `markmap-${Math.random().toString(36).slice(2, 9)}`;

// URL base para BibleGateway
const BIBLE_GATEWAY_URL = 'https://www.biblegateway.com/passage/?search=';
const BIBLE_VERSION = 'RVR1960';

// Función para convertir referencias bíblicas en enlaces
const addBibleLinks = (md: string) => {
  // Patrón mejorado para detectar referencias bíblicas (ej: "Juan 3:16", "1 Corintios 13:1-13", "Salmos 23:1")
  // Soporta libros con números (1 Juan, 2 Corintios), con tildes y la letra ñ
  const bibleRefPattern = /^(\s*-\s+)([0-9]?\s*[A-ZÁÉÍÓÚa-záéíóúñÑ]+(?:\s+[A-ZÁÉÍÓÚa-záéíóúñÑ]+)*\s+[0-9]+:[0-9]+(?:-[0-9]+)?)$/gm;
  
  return md.replace(bibleRefPattern, (match, prefix, reference) => {
    // Codificar la referencia para URL
    const encodedRef = encodeURIComponent(reference.trim());
    // Crear el enlace HTML
    return `${prefix}<a href="${BIBLE_GATEWAY_URL}${encodedRef}&version=${BIBLE_VERSION}" target="_blank">${reference}</a>`;
  });
};

// Función para asegurar que el markdown tenga el formato correcto
const formatMarkdown = (md: string) => {
  // Primero, normalizar los saltos de línea
  let result = md.replace(/\r\n/g, '\n');
  
  // Asegurar que los elementos de lista usen guiones consistentemente
  result = result.replace(/^\s*\*/gm, '-');
  
  // Preservar la jerarquía de las listas anidadas
  // Convertir sangrías de tabulaciones a 2 espacios
  result = result.replace(/\t/g, '  ');
  
  // Asegurar que los elementos de lista tengan un espacio después del guión
  result = result.replace(/^(\s*)-(\S)/gm, '$1- $2');
  
  // Asegurar que haya una línea en blanco antes de las listas después de encabezados
  result = result.replace(/(## .+)\n-/g, '$1\n\n-');
  
  // Agregar enlaces a referencias bíblicas
  result = addBibleLinks(result);
  
  return result;
};

const formattedContent = formatMarkdown(content);
const transformer = new Transformer();
const { root } = transformer.transform(formattedContent);
const assets = transformer.getAssets();

const dataStr = JSON.stringify(root ?? {});
const assetsStr = JSON.stringify(assets ?? {});
---

<div class="markmap-wrapper" style={`height: ${height};`}>
  <svg id={elementId} class="markmap-svg" xmlns="http://www.w3.org/2000/svg" data-markmap-data={dataStr}></svg>
</div>


<script>
  import { Markmap } from 'markmap-view';

  // Función para obtener los colores según el tema actual
  function getColorFunction() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    
    const colors = isDark
      ? ['#60a5fa', '#34d399', '#fbbf24', '#f87171', '#a78bfa', '#fb923c', '#22d3ee', '#fb7185']
      : ['#2563eb', '#059669', '#d97706', '#dc2626', '#7c3aed', '#ea580c', '#0891b2', '#e11d48'];
    
    return (node: any) => colors[node.state.id % colors.length];
  }

  // Función para inicializar un markmap específico
  function initializeMarkmap(svg: SVGElement) {
    const dataStr = svg.getAttribute('data-markmap-data');
    
    if (!dataStr) {
      return;
    }

    try {
      const data = JSON.parse(dataStr);
      
      const mm = new Markmap(svg, {
        duration: 500,
        maxWidth: 0,
        initialExpandLevel: -1,  // Expandir todos los niveles
        fitRatio: 0.9,           // Ratio de ajuste para dejar margen
        nodeMinHeight: 16,
        spacingVertical: 5,
        spacingHorizontal: 80,
        paddingX: 8,
        color: getColorFunction(),
        autoFit: true,           // Ajuste automático
        zoom: true,              // Habilitar zoom
        pan: true,               // Habilitar paneo
      });
      
      mm.setData(data);
      
      // Guardar la instancia para poder actualizarla
      (svg as any).__markmap__ = mm;
      
      // Forzar ajuste completo del gráfico después de renderizar
      setTimeout(() => {
        mm.fit();
        updateTextColors();
      }, 150);
      
    } catch (err) {
      console.error('Error al inicializar Markmap:', err);
    }
  }

  // Función para actualizar el color del texto en el SVG
  function updateTextColors() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    const textColor = isDark ? '#ffffff' : '#1e293b';
    
    const markmapSvgs = document.querySelectorAll('.markmap-svg');
    markmapSvgs.forEach((svg) => {
      // Actualizar TODOS los elementos de texto sin excepción
      svg.querySelectorAll('text').forEach((el: any) => {
        el.style.fill = textColor;
        el.setAttribute('fill', textColor);
      });
      
      // Actualizar todos los tspan (texto dentro de los nodos)
      svg.querySelectorAll('tspan').forEach((el: any) => {
        el.style.fill = textColor;
        el.setAttribute('fill', textColor);
      });
      
      // Actualizar todos los elementos foreignObject (si existen)
      svg.querySelectorAll('foreignObject').forEach((el: any) => {
        el.style.color = textColor;
      });
      
      // Actualizar todos los divs dentro del SVG
      svg.querySelectorAll('div').forEach((el: any) => {
        el.style.color = textColor;
      });
      
      // Actualizar enlaces
      svg.querySelectorAll('a').forEach((el: any) => {
        el.style.fill = textColor;
        el.style.color = textColor;
        el.setAttribute('fill', textColor);
      });
      
      // Actualizar cualquier span
      svg.querySelectorAll('span').forEach((el: any) => {
        el.style.color = textColor;
      });
    });
  }

  // Función para actualizar los colores cuando cambia el tema
  function updateMarkmapTheme() {
    const markmapSvgs = document.querySelectorAll('.markmap-svg');
    markmapSvgs.forEach((svg) => {
      const mm = (svg as any).__markmap__;
      if (mm) {
        mm.setOptions({ color: getColorFunction() });
        mm.fit();
      }
    });
    
    // Actualizar colores de texto
    updateTextColors();
  }

  // Ocultar cualquier imagen estática que se esté mostrando
  const hideStaticOverlay = `
    document.querySelectorAll('img[src*="markmap"]').forEach(img => {
      img.style.display = 'none';
    });
  `;

  // Inicializar el markmap
  document.addEventListener('DOMContentLoaded', () => {
    eval(hideStaticOverlay);
    
    const markmapSvgs = document.querySelectorAll('.markmap-svg');
    markmapSvgs.forEach((svg) => {
      while (svg.firstChild) {
        svg.removeChild(svg.firstChild);
      }
      initializeMarkmap(svg as unknown as SVGElement);
    });
  });

  // También inicializar si el DOM ya está listo
  if (document.readyState !== 'loading') {
    setTimeout(() => {
      eval(hideStaticOverlay);
      const markmapSvgs = document.querySelectorAll('.markmap-svg');
      markmapSvgs.forEach((svg) => {
        while (svg.firstChild) {
          svg.removeChild(svg.firstChild);
        }
        initializeMarkmap(svg as unknown as SVGElement);
      });
    }, 50);
  }

  // Observar cambios en el atributo data-theme para actualizar los colores
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
        updateMarkmapTheme();
      }
    });
  });

  // Observar el elemento html para detectar cambios de tema
  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['data-theme']
  });
  
  // Aplicar colores de texto al cargar
  setTimeout(() => updateTextColors(), 200);
</script>

<style>
  .markmap-wrapper {
    width: 100%;
    border: 1px solid var(--sl-color-gray-5);
    border-radius: 12px;
    overflow: hidden;
    background: var(--sl-color-bg);
    transition: background-color 0.3s ease, border-color 0.3s ease;
  }

  .markmap-svg {
    width: 100%;
    height: 100%;
  }

  /* Texto de los nodos - forzar colores según tema */
  .markmap-svg text,
  .markmap-svg tspan,
  .markmap-svg a,
  .markmap-svg foreignObject,
  .markmap-svg div,
  .markmap-svg span {
    transition: fill 0.3s ease, color 0.3s ease !important;
  }
  
  /* Modo claro - texto oscuro */
  :root[data-theme='light'] .markmap-svg text,
  :root[data-theme='light'] .markmap-svg tspan,
  :root[data-theme='light'] .markmap-svg a,
  :root[data-theme='light'] .markmap-svg foreignObject,
  :root[data-theme='light'] .markmap-svg div,
  :root[data-theme='light'] .markmap-svg span {
    fill: #1e293b !important;
    color: #1e293b !important;
  }

  /* Modo oscuro - texto BLANCO para TODOS los niveles */
  :root[data-theme='dark'] .markmap-svg text,
  :root[data-theme='dark'] .markmap-svg tspan,
  :root[data-theme='dark'] .markmap-svg a,
  :root[data-theme='dark'] .markmap-svg foreignObject,
  :root[data-theme='dark'] .markmap-svg foreignObject *,
  :root[data-theme='dark'] .markmap-svg div,
  :root[data-theme='dark'] .markmap-svg span {
    fill: #ffffff !important;
    color: #ffffff !important;
  }

</style>
